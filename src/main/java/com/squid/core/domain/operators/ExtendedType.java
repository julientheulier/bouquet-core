/*******************************************************************************
 * Copyright Â© Squid Solutions, 2016
 *
 * This file is part of Open Bouquet software.
 *  
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation (version 3 of the License).
 *
 * There is a special FOSS exception to the terms and conditions of the 
 * licenses as they are applied to this program. See LICENSE.txt in
 * the directory of this program distribution.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Squid Solutions also offers commercial licenses with additional warranties,
 * professional functionalities or services. If you purchase a commercial
 * license, then it supersedes and replaces any other agreement between
 * you and Squid Solutions (above licenses and LICENSE.txt included).
 * See http://www.squidsolutions.com/EnterpriseBouquet/
 *******************************************************************************/
package com.squid.core.domain.operators;

import java.sql.Types;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.squid.core.domain.CustomTypes;
import com.squid.core.domain.IDomain;

/**
 * ExtendedType is a mix between the IDomain generic type definition and a SQL concrete type definition. The ExtendedType can be generated by a ColumnType object.
 * An ExtendedType is useful to create a SQL DDL where we need a concrete type definition.
 * @author sfantino
 *
 */
public class ExtendedType {

    public static final ExtendedType UNDEFINED = new ExtendedType(IDomain.UNKNOWN,"UNDEFINED",Types.NULL,0,0);
    public static final ExtendedType TINYINT = new ExtendedType(IDomain.NUMERIC,"TINYINT",Types.TINYINT,0,3);
    public static final ExtendedType SMALLINT = new ExtendedType(IDomain.NUMERIC,"SMALLINT",Types.SMALLINT,0,5);
    public static final ExtendedType INTEGER = new ExtendedType(IDomain.NUMERIC,"INTEGER",Types.INTEGER,0,11);
    public static final ExtendedType BIGINT = new ExtendedType(IDomain.NUMERIC,"BIGINT",Types.BIGINT,0,19);
    public static final ExtendedType BOOLEAN = new ExtendedType(IDomain.CONDITIONAL,"BOOLEAN",Types.BOOLEAN,0,1);
    public static final ExtendedType FLOAT = new ExtendedType(IDomain.NUMERIC,"FLOAT",Types.FLOAT,0,15);
    public static final ExtendedType REAL = new ExtendedType(IDomain.NUMERIC,"REAL",Types.REAL,0,7);
    public static final ExtendedType NUMERIC = new ExtendedType(IDomain.NUMERIC,"NUMERIC",Types.NUMERIC,2,10);
    public static final ExtendedType CONDITIONAL = BOOLEAN;
    public static final ExtendedType DATE = new ExtendedType(IDomain.DATE,"DATE",Types.DATE,0,0);
    public static final ExtendedType TIMESTAMP = new ExtendedType(IDomain.TIMESTAMP,"TIMESTAMP",Types.TIMESTAMP,6,0);
    public static final ExtendedType TIME = new ExtendedType(IDomain.TIME,"TIME",Types.TIME,0,0);
    public static final ExtendedType INTERVAL = new ExtendedType(IDomain.INTERVAL,"INTERVAL",CustomTypes.INTERVAL,0,0);
    public static final ExtendedType STRING = new ExtendedType(IDomain.STRING,"VARCHAR",Types.VARCHAR,0,250);

    @JsonIgnore
    private IDomain domain = IDomain.NULL;

    private String name = "NULL";
    private int dataType = java.sql.Types.NULL;
    private int scale = 0;
    private int size = 0;

    public ExtendedType() {
        //
    }

    public ExtendedType(IDomain domain, int dataType) {
        super();
        this.dataType = dataType;
        this.domain = domain;
        this.name = getTypeName(dataType);
    }

    public ExtendedType(IDomain domain, String name, int dataType, int scale, int size) {
        super();
        this.name = name;
        this.dataType = dataType;
        this.domain = domain;
        this.scale = scale;
        this.size = size;
    }

    public ExtendedType(IDomain domain, int dataType, int scale, int size) {
        super();
        this.name = getTypeName(dataType);
        this.dataType = dataType;
        this.domain = domain;
        this.scale = scale;
        this.size = size;
    }

    public ExtendedType(ExtendedType copy) {
        super();
        this.name = copy.name;
        this.dataType = copy.dataType;
        this.domain = copy.domain;
        this.scale = copy.scale;
        this.size = copy.size;
    }

    public ExtendedType(IDomain domain, ExtendedType copy) {
        this(copy);
        this.domain = domain;
    }

    /**
     * return the java.sql.Types
     * @return
     */
    public int getDataType() {
        return dataType;
    }

    /**
     * return the type name as defined by the database (may be specific to the database and thus carry more information than the normalized getDataType()
     * @return
     */
    public String getName() {
        return name;
    }

    /**
     * return the full type definition with size and scale if defined. Warning: this is not SQL compliant.
     * @return
     */
    @JsonIgnore
    public String getTypeDefinition() {
        if (getScale() == 0) {
            return getName() + "(" + getSize() + ")";
        } else {
            return getName() + "(" + getSize() + "," + getScale() + ")";
        }
    }
    
    /**
     * return the internal domain
     * @return
     */
    public IDomain getDomain() {
        return domain;
    }

    public void computeDomain() {
        this.domain = computeDomain(this.dataType, this.size, this.scale);
    }
    
    /**
     * get the type scale
     * @return
     */
    public int getScale() {
        return scale;
    }
    
    /**
     * get the type size
     * @return
     */
    public int getSize() {
        return size;
    }
    
    /**
     * return a new ExtendedType with the new scale
     * @param scale
     * @return a new ExtendedType
     */
    public ExtendedType scale(int scale) {
    	ExtendedType copy = new ExtendedType(this);
    	copy.scale = scale;
    	return copy;
    }
    
    /**
     * return a new ExtendedType with the new size
     * @param size
     * @return a new ExtendedType
     */
    public ExtendedType size(int size) {
    	ExtendedType copy = new ExtendedType(this);
    	copy.size = size;
    	return copy;
    }

    
    /**
     * return a new ExtendedType with the new scale & size
     * @param size
     * @return a new ExtendedType
     */
    public ExtendedType scaleAndsize(int scale, int size) {
    	ExtendedType copy = new ExtendedType(this);
    	copy.scale = scale;
    	copy.size = size;
    	return copy;
    }

    @JsonIgnore
    public boolean isInteger() {
        switch (this.dataType) {
        case Types.BIGINT:
        case Types.INTEGER:
        case Types.SMALLINT:
        case Types.TINYINT:
            return true;
        case Types.NUMERIC:
        case Types.DECIMAL:
            return scale==0;
        default:
            return false;
        }
    }

    /**
     * return true if the type is a number with exact precision (that is it is NOT a real, float, double)
     * @return
     */
    @JsonIgnore
    public boolean isExactNumber() {
        switch (this.dataType) {
        case Types.BIGINT:
        case Types.INTEGER:
        case Types.SMALLINT:
        case Types.TINYINT:
        case Types.NUMERIC:
        case Types.DECIMAL:
            return true;
        default:
            return false;
        }
    }

    @Override
    public boolean equals(Object object) {
        if (this==object) {
            return true;
        } else if (object instanceof ExtendedType) {
            ExtendedType type = (ExtendedType)object;
            if (type.getDataType()==this.getDataType()) {
                switch (type.getDataType()) {
                case Types.DECIMAL:
                case Types.NUMERIC:
                    return type.getScale()==this.getScale()
                    && type.getSize()==this.getSize();
                case Types.NVARCHAR:
                case Types.VARCHAR:
                case Types.CHAR:
                    return type.getSize()==this.getSize();
                default:
                    return true;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    public static final int STRING_ORDER = 1;
    public static final int DATE_ORDER = 5;
    public static final int NUMBER_ORDER = 10;
    public static final int UNKNOWN_ORDER = 100;

    /**
     * compute a type "order" that can be used to compare types and promote types.
     * The order is a couple (x,y), where x represent a family type (string,date,numbers) and y an order in that family
     * A type should be promoted to the higher order.
     * @return
     */
    public int[] computeTypeOrder() {
        switch (getDataType()) {
        case Types.BIT:
            return new int[]{NUMBER_ORDER,0};
        case Types.BOOLEAN:
            return new int[]{NUMBER_ORDER,1};
        case Types.TINYINT:
            return new int[]{NUMBER_ORDER,2};
        case Types.SMALLINT:
            return new int[]{NUMBER_ORDER,3};
        case Types.INTEGER:
            return new int[]{NUMBER_ORDER,4};
        case Types.BIGINT:
            return new int[]{NUMBER_ORDER,5};
            ///////////////////////////
        case Types.REAL:
            return new int[]{NUMBER_ORDER,6};
        case Types.DOUBLE:
        case Types.FLOAT:
            return new int[]{NUMBER_ORDER,7};
        case Types.DECIMAL:
            return new int[]{NUMBER_ORDER,8};
        case Types.NUMERIC:
            return new int[]{NUMBER_ORDER,9};
            //////////////////////////
        case Types.CHAR:
            return new int[]{STRING_ORDER,0};
        case Types.VARCHAR:
            return new int[]{STRING_ORDER,1};
        case Types.LONGVARCHAR:
            return new int[]{STRING_ORDER,2};
        case Types.CLOB:
            return new int[]{STRING_ORDER,3};
            ///////////////////////////
        case Types.TIME:
            return new int[]{DATE_ORDER,1};
        case Types.DATE:
            return new int[]{DATE_ORDER,2};
        case Types.TIMESTAMP:
            return new int[]{DATE_ORDER,3};
        case CustomTypes.INTERVAL:
            return new int[]{DATE_ORDER,4};
            ///////////////////////////
        default:
            return new int[]{UNKNOWN_ORDER,0};
        }
    }


    private String getTypeName(int SQLType) {
        switch (SQLType) {
        case Types.ARRAY:return "ARRAY";
        case Types.BIGINT:return "INTEGER";
        case Types.BINARY:return "BINARY";
        case Types.BIT:return "BIT";
        case Types.BLOB:return "BLOB";
        case Types.BOOLEAN:return "BOOLEAN";
        case Types.CHAR:return "CHAR";
        case Types.CLOB:return "CLOB";
        case Types.DATALINK:return "DATALINK";
        case Types.DATE:return "DATE";
        case Types.DECIMAL:return "DECIMAL";
        case Types.DOUBLE:return "DOUBLE";
        case Types.FLOAT:return "FLOAT";
        case Types.INTEGER:return "INTEGER";
        case Types.JAVA_OBJECT:return "JAVA_OBJECT";
        case Types.LONGNVARCHAR:return "LONGNVARCHAR";
        case Types.LONGVARBINARY:return "LONGVARBINARY";
        case Types.NCHAR:return "NCHAR";
        case Types.NCLOB:return "NCLOB";
        case Types.NULL:return "UNDEFINED";//
        case Types.NUMERIC:return "NUMERIC";
        case Types.NVARCHAR:return "NVARCHAR";
        case Types.OTHER:return "UNDEFINED";//
        case Types.REAL:return "REAL";
        case Types.REF:return "REF";
        case Types.ROWID:return "ROWID";
        case Types.SMALLINT:return "SMALLINT";
        case Types.SQLXML:return "SQLXML";
        case Types.STRUCT:return "STRUCT";
        case Types.TIME:return "TIME";
        case Types.TIMESTAMP:return "TIMESTAMP";
        case Types.TINYINT:return "TINYINT";
        case Types.VARBINARY:return "VARBINARY";
        case Types.VARCHAR:return "VARCHAR";
        default:return "UNDEFINED";//
        }
    }
    
    public static int FromTypeName(String SQLName) {
    	if (SQLName.equals("ARRAY")){
    		return Types.ARRAY;
    	}
    	if (SQLName.equals("INTEGER")){
    		return Types.INTEGER;
    	}
    	if (SQLName.equals("BINARY")){
    		return Types.BINARY;
    	}
    	if (SQLName.equals("BIT")){
    		return Types.BIT;
    	}
    	if (SQLName.equals("BLOB")){
    		return Types.BLOB;
    	}
    	if (SQLName.equals("BOOLEAN")){
    		return Types.BOOLEAN;
    	}
    	if (SQLName.equals("CHAR")){
    		return Types.CHAR;
    	}
    	if (SQLName.equals("CLOB")){
    		return Types.CLOB;
    	}
    	if (SQLName.equals("DATALINK")){
    		return Types.DATALINK;
    	}
    	if (SQLName.equals("DATE")){
    		return Types.DATE;
    	}
    	if (SQLName.equals("DECIMAL")){
    		return Types.DECIMAL;
    	}
    	if (SQLName.equals("DOUBLE")){
    		return Types.DOUBLE;
    	}
    	if (SQLName.equals("FLOAT")){
    		return Types.FLOAT;
    	}
    	if (SQLName.equals("JAVA_OBJECT")){
    		return Types.JAVA_OBJECT;
    	}
    	if (SQLName.equals("LONGNVARCHAR")){
    		return Types.LONGNVARCHAR;
    	}
    	if (SQLName.equals("LONGVARBINARY")){
    		return Types.LONGVARBINARY;
    	}
    	if (SQLName.equals("NCHAR")){
    		return Types.NCHAR;
    	}
    	if (SQLName.equals("NCLOB")){
    		return Types.NCLOB;
    	}
    	if (SQLName.equals("UNDEFINED")){
    		return Types.OTHER;
    	}
    	if (SQLName.equals("NUMERIC")){
    		return Types.NUMERIC;
    	}
    	if (SQLName.equals("NVARCHAR")){
    		return Types.NVARCHAR;
    	}
    	if (SQLName.equals("REAL")){
    		return Types.REAL;
    	}
    	if (SQLName.equals("REF")){
    		return Types.REF;
    	}
    	if (SQLName.equals("ROWID")){
    		return Types.ROWID;
    	}
    	if (SQLName.equals("SMALLINT")){
    		return Types.SMALLINT;
    	}
    	if (SQLName.equals("SQLXML")){
    		return Types.SQLXML;
    	}
    	if (SQLName.equals("STRUCT")){
    		return Types.STRUCT;
    	}
    	if (SQLName.equals("TIME")){
    		return Types.TIME;
    	}
    	if (SQLName.equals("TIMESTAMP")){
    		return Types.TIMESTAMP;
    	}
    	if (SQLName.equals("TINYINT")){
    		return Types.TINYINT;
    	}
    	if (SQLName.equals("VARCHAR")){
    		return Types.VARCHAR;
    	}
    	if (SQLName.equals("VARBINARY")){
    		return Types.VARBINARY;
    	}
        return Types.OTHER;
    }

    public static IDomain computeDomain(int data_type, int size, int scale) {
        switch (data_type) {
        case Types.BOOLEAN:
        case Types.BIT:// on PG systems, this is how a boolean is actually represented by the driver
            return IDomain.BOOLEAN;
        case Types.TINYINT:
        case Types.BIGINT:
        case Types.INTEGER:
        case Types.SMALLINT:
            return IDomain.NUMERIC;
            ///////////////////////////
        case Types.REAL:
        case Types.DOUBLE:
        case Types.FLOAT:
            return IDomain.CONTINUOUS;
        case Types.NUMERIC:
        case Types.DECIMAL:
            return scale > 0 || size == 0 ? IDomain.CONTINUOUS
                    : IDomain.NUMERIC;
        case Types.CHAR:
        case Types.NCHAR:
        case Types.VARCHAR:
        case Types.NVARCHAR:
        case Types.LONGVARCHAR:
        case Types.CLOB:
            return IDomain.STRING;
            ///////////////////////////
        case Types.TIME:
            return IDomain.TIME;
        case Types.DATE:
            return IDomain.DATE;
        case Types.TIMESTAMP:
            return IDomain.TIMESTAMP;
            ///////////////////////////
        default:
            return IDomain.UNKNOWN;
        }
    }
    
    @Override
    public String toString() {
    	return this.getTypeDefinition()+" ("+getDomain().toString()+")";
    }

}
